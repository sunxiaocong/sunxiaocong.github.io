

##　ElasticSearch 简介

###　基础概念

#### 准实时

Elasticsearch是一个近实时搜索平台。 这意味着从索引文档到可搜索文档的时间有一点延迟（通常是一秒）。

不过使用Get直接查询时，是实时的，Get请求会直接读内存中的数据TransLog．



#### 集群

节点是作为群集一部分的单个服务器，存储数据并参与群集的索引和搜索功能。与集群一样，节点由名称标识，默认情况下，该名称是在启动时分配给节点的随机通用唯一标识符（UUID）。如果不需要默认值，可以定义所需的任何节点名称。此名称对于管理目的非常重要，您可以在其中识别网络中的哪些服务器与Elasticsearch集群中的哪些节点相对应。

可以将节点配置为按群集名称加入特定群集。默认情况下，每个节点都设置为加入名为elasticsearch的集群，这意味着如果您在网络上启动了许多节点并且假设它们可以相互发现 - 它们将自动形成并加入名为elasticsearch的单个集群。

在单个群集中，您可以拥有任意数量的节点。此外，如果您的网络上当前没有其他Elasticsearch节点正在运行，则默认情况下启动单个节点将形成名为elasticsearch的新单节点集群。



#### 索引

索引是具有某些类似特征的文档集合。 例如，您可以拥有客户数据的索引，产品目录的另一个索引以及订单数据的另一个索引。 索引由名称标识（必须全部为小写），并且此名称用于在对其中的文档执行索引，搜索，更新和删除操作时引用索引。

在单个群集中，您可以根据需要定义任意数量的索引。



#### 文档

文档是可以编制索引的基本信息单元。 例如，您可以为单个客户提供文档，为单个产品提供另一个文档，为单个订单提供另一个文档。 该文档以JSON（JavaScript Object Notation）表示，JSON是一种普遍存在的互联网数据交换格式。

在索引/类型中，您可以根据需要存储任意数量的文档。 请注意，尽管文档实际上位于索引中，但实际上必须将文档编入索引/分配给索引中的类型。



#### 分片与副本

索引可能存储大量可能超过单个节点的硬件限制的数据。例如，占用1TB磁盘空间的十亿个文档的单个索引可能不适合单个节点的磁盘，或者可能太慢而无法单独从单个节点提供搜索请求。

为了解决这个问题，Elasticsearch提供了将索引细分为多个称为分片的功能。创建索引时，只需定义所需的分片数即可。每个分片本身都是一个功能齐全且独立的“索引”，可以托管在集群中的任何节点上。

分片很重要，主要有两个原因：

- 它允许您水平分割/缩放内容量

- 它允许您跨分片（可能在多个节点上）分布和并行化操作，从而提高性能/吞吐量
  分片的分布方式以及如何将文档聚合回搜索请求的机制完全由Elasticsearch管理，对用户来说是透明的。

在任何时候都可以预期出现故障的网络/云环境中，非常有用，强烈建议使用故障转移机制，以防分片/节点以某种方式脱机或因任何原因消失。为此，Elasticsearch允许您将索引的分片的一个或多个副本制作成所谓的副本分片或简称副本。

复制很重要，主要有两个原因：

- 它在碎片/节点出现故障时提供高可用性。因此，请务必注意，副本分片永远不会在与从中复制的原始/主分片相同的节点上分配。
- 它允许您扩展搜索量/吞吐量，因为可以在所有副本上并行执行搜索。

总而言之，每个索引可以拆分为多个分片。索引也可以复制为零（表示没有副本）或更多次。复制后，每个索引都将具有主分片（从中复制的原始分片）和副本分片（主分片的副本）。

可以在创建索引时为每个索引定义分片和副本的数量。创建索引后，您还可以随时动态更改副本数。您可以使用_shrink和_split API更改现有索引的分片数，但这不是一项简单的任务，预先计划正确数量的分片是最佳方法。

默认情况下，Elasticsearch中的每个索引都分配了5个主分片和1个副本，这意味着如果群集中至少有两个节点，则索引将包含5个主分片和另外5个副本分片（1个完整副本），总计为每个索引10个分片。



#### Shrink Index

收缩索引API允许您将现有索引缩减为具有较少主分片的新索引。目标索引中请求的主分片数必须是源索引中分片数的一个因子。例如，具有8个主分片的索引可以缩小为4个，2个或1个主分片，或者具有15个主分片的索引可以缩小为5个，3个或1个。如果索引中的分片数是素数，它可以只能缩小为一个主要分片。在收缩之前，索引中每个分片的（主要或副本）副本必须存在于同一节点上。

收缩的工作原理如下：

- 首先，它创建一个新的目标索引，其定义与源索引相同，但主分片数量较少。

- 然后，它将源索引中的段硬链接到目标索引。 （如果文件系统不支持硬链接，则会将所有段复制到新索引中，这是一个更耗时的过程。）

- 最后，它恢复了目标索引，好像它是一个刚重新打开的封闭索引。

为shrinkingedit准备索引为了收缩索引，必须将索引标记为只读，并且索引中每个分片的（主要或副本）副本必须重定位到同一节点并且运行状况为绿色。

可以通过以下请求实现这两个条件：

```
PUT / my_source_index / settings
{
  “设置”：{
    “index.routing.allocation.require.name”：“shrink_node_name”，
    “index.blocks.write”：true
  }
}
```


作为CURLVIEW在CONSOLE中复制

- 强制将每个分片的副本重定位到名为shrink_node_name的节点。有关更多选项，请参阅Shard Allocation Filtering。

- 阻止对此索引的写入操作，同时仍允许更改元数据，如删除索引。

重新定位源索引可能需要一段时间。可以使用_cat恢复API跟踪进度，或者可以使用集群运行状况API等待所有分片都使用wait_for_no_relocating_shards参数重定位。

收缩indexedit

要将my_source_index缩小为名为my_target_index的新索引，请发出以下请求：

```
POST my_source_index / shrink / my_target_index？copy_settings = true
{
  “设置”：{
    “index.routing.allocation.require.name”：null，
    “index.blocks.write”：null
  }
}
```

- 作为CURLVIEW在CONSOLE中复制

- 清除从源索引复制的分配要求。

- 清除从源索引复制的索引写入块。

一旦将目标索引添加到集群状态，上述请求就会立即返回 - 它不会等待收缩操作开始。


指数只有满足以下要求才能缩小：

- 目标索引不得存在
- 索引必须具有比目标索引更多的主分片。
- 目标索引中的主分片数必须是源索引中主分片数的一个因子。源索引必须具有比目标索引更多的主分片。
- 所有分片中的索引总数不得超过2,147,483,519个，这些分片将缩小为目标索引上的单个分片，因为这是可以放入单个分片的最大文档数。
- 处理收缩过程的节点必须具有足够的可用磁盘空间，以容纳现有索引的第二个副本。

_shrink API类似于create index API，并接受目标索引的设置和别名参数：

```
POST my_source_index / _shrink / my_target_index？copy_settings = true
{
  “设置”：{
    “index.number_of_replicas”：1，
    “index.number_of_shards”：1，
    “index.codec”：“best_compression”
  }，
  “别名”：{
    “my_search_indices”：{}
  }
}
```




作为CURLVIEW在CONSOLE中复制


目标索引中的分片数。这必须是源索引中分片数量的一个因素。



最佳压缩仅在对索引进行新写入时生效，例如将分片强制合并到单个段时。

注意
可能未在_shrink请求中指定映射。

注意
默认情况下，除index.analysis，index.similarity和index.sort设置外，源索引上的索引设置不会在收缩操作期间复制。除了不可复制的设置之外，可以通过将URL参数copy_settings = true添加到请求来将源索引中的设置复制到目标索引。请注意，copy_settings不能设置为false。参数copy_settings将在8.0.0中删除

[6.4.0]在6.4.0中弃用。不建议使用复制设置

监控收缩处理
可以使用_cat恢复API监视收缩过程，或者可以使用集群运行状况API等待，直到通过将wait_for_status参数设置为黄色来分配所有主分片。

在分配任何分片之前，只要目标索引已添加到群集状态，_shrink API就会返回。此时，所有分片都处于未分配状态。如果出于任何原因，目标


